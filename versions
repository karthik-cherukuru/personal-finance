# PROJECT VERSIONS

## Version 1

### Next.js Application with Google Authentication and Supabase: A Technical Journey

Our project is a modern web application built with Next.js 14, leveraging its App Router architecture to create a seamless user experience with server and client components. We've implemented a robust authentication system using NextAuth.js with Google OAuth, allowing users to sign in securely with their Google accounts. For data persistence, we integrated Supabase as our backend service, which provides a PostgreSQL database with Row Level Security policies to ensure data privacy. The application follows a clean separation of concerns: the `/app` directory contains route-specific components, `/components` houses reusable UI elements, and `/lib` stores utility functions and service integrations. This architecture follows industry best practices by separating UI, business logic, and data access layers, making the codebase maintainable and scalable.

Authentication presented several interesting challenges we methodically solved. First, we needed to create proper sign-in and error pages in the `/auth` directory to match NextAuth's configuration. When users attempt to sign in, they trigger the Google OAuth flow through our client-side button component (marked with "use client" directive). After successful authentication, NextAuth's callback processes the user information and stores it in Supabase using our custom `upsertUser` function. We encountered and resolved React hydration errors that occurred when mixing server and client-side rendering - a common Next.js pitfall - by carefully structuring our components. By implementing server-side session checks and client-side interactivity, we created a seamless authentication experience that handles edge cases gracefully.

For user profile management, we created a system that combines data from two sources: basic information from Google OAuth and additional user metadata from Supabase. We designed a simplified `UserData` type that includes essential fields like id, email, name, and profile image URL. The profile page fetches user data server-side and displays it in a clean, left-aligned card layout. To handle potential database connectivity issues, we implemented graceful degradation through placeholder data in case Supabase queries fail. We originally tracked timestamps for user creation and last login but later simplified the schema by removing these fields based on evolving requirements. The Supabase integration layer includes comprehensive error handling for various scenarios, from table existence checks to unique constraint violations, ensuring robust user data management even under unexpected conditions.

The most technically challenging aspect was handling profile images, particularly those from Google's CDN which sometimes time out or fail to load. We engineered a resilient `ProfileImage` component that implements several advanced techniques: automatic retries when browser tabs regain visibility, timeout detection with fallback icons, and cache-busting for Google image URLs to prevent stale caches. This component uses React's useEffect and useRef hooks to manage loading states and network requests efficiently. We solved hard-to-debug React hydration mismatches by avoiding dynamic values during initial renders and moving timestamp generation to client-side effects. The UI design throughout the application follows a consistent approach using shadcn components styled with Tailwind CSS, ensuring responsive behavior across devices. This attention to detail in handling edge cases, particularly around image loading and authentication flows, demonstrates how production-quality applications must anticipate and gracefully handle failure modes beyond the happy path.

## Version 2

### Enhanced Transaction Management with Interactive Modal and Account Controls

In Version 2, we focused on enhancing the transaction management capabilities and user control over data. The centerpiece of this update is a sophisticated transaction details modal that appears when users click on a transaction in the "Recent Transactions" list. This modal displays comprehensive transaction information including amount, name, date, time, and transaction type, while implementing a backdrop blur effect for improved visual hierarchy. The most technically interesting feature is the ability to rename transactions by clicking an edit icon, which transforms the display into an editable field with save functionality. This required creating a robust state management system that handles editing states, validation, and synchronization with the backend.

Building the transaction management system required us to overcome several technical challenges. First, we needed to integrate Radix UI Dialog components to create an accessible modal that smoothly transitions in and out of view. We created a custom dialog component that manages focus trapping and keyboard navigation for accessibility. For the transaction renaming feature, we implemented optimistic UI updates combined with error handling to provide immediate feedback while ensuring data consistency. We also had to carefully manage state resets between modal openings to prevent stale data from appearing briefly. A particularly interesting problem was ensuring that renamed transactions would immediately reflect in both the modal and the transaction list, which we solved through a clever callback system that propagates changes up through the component tree.

To enhance user control over their data, we implemented two critical account management features: the ability to unlink Google authorization and the ability to delete all transactions. The Google unlinking feature was implemented by creating an API endpoint that removes the user's token data from their Supabase table, effectively revoking Gmail access permissions. For the transaction deletion feature, we tackled a complex challenge with Supabase's Row Level Security policies by implementing a batched deletion strategy instead of attempting to delete all records at once. This pattern fetches all transaction IDs and then deletes them in manageable batches of 100, providing better performance and higher success rates while gracefully handling potential permission issues.

From an architectural perspective, we focused on robust error handling and logging throughout the system. Each API endpoint has comprehensive error checking with specific error messages that help diagnose issues. We implemented confirmations for destructive actions like deleting transactions, ensuring users don't accidentally remove important data. The dashboard settings page was also completely redesigned with a cleaner card-based layout that groups related settings together. These enhancements demonstrate our commitment to both technical excellence and user experience, creating a system that not only functions reliably but also provides intuitive controls for users to manage their data. The careful attention to transaction state management, animations, and error handling details creates a polished, production-ready feature set that balances technical sophistication with user-friendly design.
